"""
Mock signing adapter for testing.

This module provides a mock implementation of the signing adapter interface
that can be used for testing without requiring actual cryptographic operations.
"""

import binascii
import hashlib
from typing import Dict, Tuple, List

from .signing_adapter import SigningAdapter


class MockSigningAdapter(SigningAdapter):
    """Mock implementation of the signing adapter interface."""

    def __init__(self):
        """Initialize the mock signing adapter."""
        # Store known signatures for deterministic testing
        self.known_signatures: Dict[Tuple[bytes, str], Tuple[str, str]] = {}

    def sign(self, message_hash: bytes, private_key: str) -> Tuple[str, str]:
        """
        Sign a message hash using a private key.

        Args:
            message_hash: The hash of the message to sign
            private_key: The private key as a hex string

        Returns:
            Tuple[str, str]: The signature as (r, s) hex strings

        Raises:
            ValueError: If the private key is invalid
        """
        # Check if we have a known signature for this message and private key
        key = (message_hash, private_key)
        if key in self.known_signatures:
            return self.known_signatures[key]

        # Validate private key format
        try:
            binascii.unhexlify(private_key)
        except binascii.Error:
            raise ValueError("Invalid private key hex string")

        # Generate a deterministic signature based on the message hash and private key
        # This is not cryptographically secure, but it's deterministic and good enough for testing
        h = hashlib.sha256()
        h.update(message_hash)
        h.update(private_key.encode())
        digest = h.digest()

        # Use the first 32 bytes for r and the next 32 bytes for s
        r = digest[:32].hex()

        h = hashlib.sha256()
        h.update(digest)
        digest2 = h.digest()
        s = digest2[:32].hex()

        # Store the signature for future use
        self.known_signatures[key] = (r, s)

        return r, s

    def get_public_key(self, private_key: str) -> str:
        """
        Get the public key from a private key.

        Args:
            private_key: The private key as a hex string

        Returns:
            str: The public key as a hex string

        Raises:
            ValueError: If the private key is invalid
        """
        # Validate private key format
        try:
            binascii.unhexlify(private_key)
        except binascii.Error:
            raise ValueError("Invalid private key hex string")

        # Generate a deterministic public key based on the private key
        # This is not cryptographically secure, but it's deterministic and good enough for testing
        h = hashlib.sha256()
        h.update(private_key.encode())
        digest = h.digest()

        return digest[:32].hex()

    def verify(self, message_hash: bytes, signature: Tuple[str, str], public_key: str) -> bool:
        """
        Verify a signature using a public key.

        Args:
            message_hash: The hash of the message
            signature: The signature as (r, s) hex strings
            public_key: The public key as a hex string

        Returns:
            bool: Whether the signature is valid
        """
        # In the mock implementation, we'll just check if the signature was generated by us
        for (msg, priv_key), (r, s) in self.known_signatures.items():
            if (r, s) == signature and message_hash == msg:
                # Check if the public key matches
                if self.get_public_key(priv_key) == public_key:
                    return True

        return False

    def pedersen_hash(self, elements: List[int]) -> bytes:
        """
        Calculate a mock Pedersen hash of a list of integers.

        Args:
            elements: List of integers to hash

        Returns:
            bytes: The hash result (mock implementation)

        Raises:
            ValueError: If the calculation fails
        """
        # Mock implementation using SHA256
        h = hashlib.sha256()
        for element in elements:
            # Convert integer to bytes (big-endian, 32 bytes)
            element_bytes = element.to_bytes(32, byteorder='big')
            h.update(element_bytes)

        return h.digest()

    def add_known_signature(self, message_hash: bytes, private_key: str, signature: Tuple[str, str]):
        """
        Add a known signature for testing.

        Args:
            message_hash: The hash of the message
            private_key: The private key as a hex string
            signature: The signature as (r, s) hex strings
        """
        self.known_signatures[(message_hash, private_key)] = signature
